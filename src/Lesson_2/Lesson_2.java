package Lesson_2;

public class Lesson_2 {
    public static void main(String[] args) {
        int []array = {1, 3, 5, 7, 9, 11, 13};

        System.out.println(binarySearch(array, 1));
        System.out.println(binarySearch(array, 13));
        System.out.println(binarySearch(array, 4));

        /*
        Почему бинарный поиск нельзя применить к неотсортированному массиву?

        Представим, что мы передали массив [1, 13, 5, 6, 7, 11] и искомое число 13. По алгоритму получится:
        mid = 3, то есть за центр взяли число 6, которое больше искомого нами числа, а значит мы будем искать число 13
        в большей половине массива и не найдём, так как массив не отсортирован и число 13 находится в меньшей половине

        Какая асимптотическая сложность алгоритма по времени и почему это O(log n)?
        Если точнее, то конкретно сложность экземляра log(2)n c округлением вниз + 1.
        Мы постоянно делим массив на 2 части
        n / 2, затем делим еще на 2: (n / 2) / 2 = n / 4 и т.д.
        В конце у нас должен остаться последний элемент для проверки, которые либо будет искомым нами элементом,
        либо мы убедимся, что искомого элемента в массиве нет.
        n / 2^k = 1 - должен остаться 1 элемент
        n = 2^k
        по определению логарифма
        k = log2(n)
        но тут надо еще + 1, так как осталась последняя проверка, является ли последний элемент искомым нами, поэтому
        k = log2(n) + 1
        но при оценке временной сложности мы не учитываем основание логарифма и константы, то сложность алгоритма
        k = O(log(n))
        По памяти сложность O(1), так как кроме переменных для хранения центра, левой и правой границ, мы память не
        выделяем



         */
    }

    public static int binarySearch(int[] array, int target) {
        int left = 0;
        int right = array.length;
        int mid;

        while (left <= right) {
            mid = left + (right - left) / 2;

            if (array[mid] == target) {
                return mid;
            } else if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
}

